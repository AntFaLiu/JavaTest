# jvm解析
## Java  的内存分配：
java GC的范围是Java堆内存：

    Java堆内存分为三代：
    年轻代：新对象和没达到一定年龄的对象都在年轻代；
    老年代：被长时间使用的对象，老年代的内存空间应该要比年轻代更大；
    元空间：像一些方法中的操作临时对象等，直接使用物理内存；
    Java  把内存分为两种   一种叫堆内存  一种叫栈内存 
    堆内存增长:  从低地址向高地址 
    栈内存地址 : 从高地址到第地址   
    堆大小 = 新生代 + 老年代。其中
    Edem : from : to = 8:1:1 
    对象在 Survivor 区每熬过一次 Minor GC，就将对象的年龄 + 1，当对象的年龄达到某个值时 ( 默认是 15 岁，可以通过参数 -XX:MaxTenuringThreshold 来设定 )，这些对象就会成为老年代。
    栈是通过esp指针，压参数esp指针地址变小，出栈，地址变大，而堆是通过brk或者mmap向系统要空间，然后堆增大   也就是说
## jvm的功能
    (1)运行时的垃圾回收，
    (2)通过 ClassLoader 寻找和装载 class 文件，解释字节码成为指令并执行，提供 class 文件的运行环境提供与硬件交互的平台
## 类加载过程
    JVM中类的装载是由ClassLoader和它的子类来实现的,Java ClassLoader 是一个重要的Java运行时系统组件
### 父类委派机制      
    先让父类做父类做不了再让子类做
    原因：使用双亲为委派机制的原因:防止类的重复加载
    Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、
    转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的加载机制。
### 加载顺序：
    一般顺序：静态块——>静态变量——>成员变量——>构造方法——>静态方法
    1、静态代码块（只加载一次） 
    2、构造方法（创建一个实例就加载一次）
    3、静态方法需要调用才会执行，所以最后结果没有
    
## Java运行时的数据区：
### PC 寄存器   
    线程私有  存放正在执行的字节码地址
       程序计数器是一块较小的区域，它的作用可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的模型里，字节码指示器就是通过改变程序计数器的值来指定下一条需要执行的指令。分支，循环等基础功能就是依赖程序计数器来完成的。
    每一条 Java虚拟机线程都有自己的 PC（ Program Counter）寄存器 
    那 PC 寄存器就保存 Java 虚拟机正在执行的字节码指令的地址，如果该方法是 native 的，那 PC 寄存器的值是 undefined。 PC 寄存器的容量至少应当能保存一个 returnAddress 类型的数据或者一个与平台相关的本地指针的值 
### Java虚拟机栈
    存放基本类型的数据和对象的引用，但对象本身不存放在栈中，而是存放在堆中 
        描述的是JAVA方法执行的内存模型：每个方法执行的时候都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法的被调用直至执行完成的过程，就对应着一个栈帧在虚拟机中从入栈到出栈的过程。所以也是线程私有的。
    是一个线程的执行区域， 它保存着一个线程中的方法的调用状态， 也可以说， 一个Java线程的运行状态， 都由一个Java栈来保存。 在这个栈中， 每一方法对应一个栈帧， 请注意区分栈帧和栈这两个概念。栈指的是整个线程的执行栈， 栈帧是栈中的一个单位， 每个方法对应一个栈帧。JVM会对Java栈执行两种操作： 压栈和出栈。 这两种操作在执行时都是以帧（栈帧）为单位的。 当调用了一个新的方法， 就会压入一个栈帧， 当一个方法调用完成， 就会弹出这个方法的栈帧， 回到调用者的栈帧。
### Java 堆
    在 Java 虚拟机中，堆（ Heap）是可供各条线程共享的运行时内存区域，也是供所有类实例和数组对象分配内存的区域
    垃圾回收器收集的区域  JAVA堆是被所有线程共享的区域
### 方法区  
    主要存储被虚拟机加载的类信息，常量、静态变量
    在 Java 虚拟机中，方法区（ Method Area） 是可供各条线程共享的运行时内存区域它存储了每一个类的结构信息，例如运行时常量池（ Runtime Constant Pool）、字段和方法数据、构造函数和普通方法的字节码内容、还包括一些在类、实例、接口初始化时用到的特殊方法 
    通常为了优化对象调用方法的速度，方法区的类型信息中增加一个指针，该指针指向一张记录该类方法入口的表（称为方法表），表中的每一项都是指向相应方法的指针
####  类信息：
#####（1）类的全限定名
#####（2）当前类的直接父类的全限定名
#####（3）这个类是接口类型，类类型，还是枚举类型
#####（4）类的访问修饰符信息
#####（5）当前类型的超接口的全限定名
#####（6）当前类型的常量池
#####（7）字段信息
#####（8）方法信息
    
### 运行时常量池 
    运行时常量池（ Runtime Constant Pool）是每一个类或接口的常量池 
    方法区的一部分，当然也是线程共享的咯。除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放各种字面量和符合引用。
    字面量和符号引用，这部分 内容在类加载后存放到方法区
    运行时的常量池相对于Class文件常量池的另外一个 重要的具备动态性，java语言并不要求常量一定只能在编译期产生，也就是并非预置入class文件中常量池的内容才能进入 方法区的常量池
    运行时常量池 相对于class文件常量池的另外一个重要的特征是具备动态性，Java语言并不要求常量一定只能在编译期产生，也就是并非置入class文件中常量池的内容才能进入方法区运行时的常量池，在运行期间也会有新的常量放进池中。这种特性被开发人员利用的比较多的便是String类的intern（）方法。
    既然运行时常量池是方法区的一部分，自然会受到方法区内存的限制，当常量无法再申请到内存的时候 会抛出outofMemoryError

## java 内存回收机制
### Java垃圾回收机制的原理：
        当创建一个对象时GC使用一系列软指针就会监控这个对象的地址和大小使用情况，并用一个对象表将这些软指针对应为对象的引用之所以称为软指针是因为他并不是直接指向对象的而是指向对象的引用。Java可以依次的检查每个对象通过更改对象表项垃圾收集器可以标记对象移除对象移动对象和检查对象
    垃圾收集器是自动运行的他会时不时的检查对象的各个引用分代。
### 垃圾收集方法：
    （1）引用计数法  
    （2）引用追踪器法（对象的引用遍历）沿着对象图上的每条链递归确定是否可达
### 常用算法：
    (1)采用的回收方法 ：分代回收
    (2)标记清除算法：容易造成内存碎片
    (3)Copying  将内存分成两块每次只是用一块    这样代价太高  算法代价太高  使用内存变为原来的一半
    (4)Mark-Compact 算法   存活对象向一端移动
### 具体过程：
    当GC线程启动时，会通过可达性分析法把Eden区和From Space区的存活对象复制到To Space区，然后把Eden Space和From Space区的对象释放掉。当GC轮训扫描To Space区一定次数后，把依然存活的对象复制到老年代，然后释放To Space区的对象。
    对象的内存分配，往大方向上讲就是在堆上分配，对象主要分配在新生代的Eden Space和From Space，少数情况下会直接分配在老年代。如果新生代的Eden Space和From Space的空间不足，则会发起一次GC，如果进行了GC之后，Eden Space和From Space能够容纳该对象就放在Eden Space和From Space。在GC的过程中，会将Eden Space和From  Space中的存活对象移动到To Space，然后将Eden Space和From Space进行清理。如果在清理的过程中，To Space无法足够来存储某个对象，就会将该对象移动到老年代中。在进行了GC之后，使用的便是Eden space和To Space了，下次GC时会将存活对象复制到From Space，如此反复循环。当对象在Survivor区躲过一次GC的话，其对象年龄便会加1，默认情况下，如果对象年龄达到15岁，就会移动到老年代中。
    （大于from或者to区的一半时就拷贝到内存区，还有就是new的对象太大时就直接放在老年代）
    生成新对象放在eden区，当Eden放满之后放
    生存年龄  复制一次熬过一次垃圾回收

#### 持久代:
    用于存放静态文件，如今Java类、方法等。
    类回收的前提这个类从来没有定义类的对象，不存在用反射的方式来释放class对象，类加载器被回收 
    垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收(Full GC)。如果你仔细查看垃圾收集器的输出信息，就会发现永久代也是被回收的。这就是为什么正确的永久代大小对避免Full GC是非常重要的原因。请参考下Java8：从永久代到元数据区
### 注：
    Java8中已经移除了永久代，新加了一个叫做元数据区的native内存区
    
### 垃圾收集器：
#### 1.Serial/Serial Old
    Serial/Serial Old收集器是最基本最古老的收集器，它是一个单线程收集器，并且在它进行垃圾收集时，必须暂停所有用户线程。Serial收集器是针对新生代的收集器，采用的是Copying算法，Serial Old收集器是针对老年代的收集器，采用的是Mark-Compact算法。它的优点是实现简单高效，但是缺点是会给用户带来停顿。
#### 2.ParNew
    ParNew收集器是Serial收集器的多线程版本，使用多个线程进行垃圾收集。
#### 3.Parallel Scavenge     目标：控制吞吐量
    Parallel Scavenge收集器是一个新生代的多线程收集器（并行收集器），它在回收期间不需要暂停其他用户线程，其采用的是Copying算法，该收集器与前两个收集器有所不同，它主要是为了达到一个可控的吞吐量。
#### 4.Parallel Old
    Parallel Old是Parallel Scavenge收集器的老年代版本（并行收集器），使用多线程和Mark-Compact算法。标记整理算法
#### 5.CMS   获取最短停顿时间   基于“标记清除算法”   并发收集  低停顿
    CMS（Current Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器，它是一种并发收集器，采用的是Mark-Sweep算法。
##### CMS缺点：
    1.对CPU资源敏感
    2.没有办法处理“浮动垃圾”肯能出出现Concurrent Mode Failure失败而导致一次Full Gc
    3.使用标记清除算法会产生大量的内存碎片
##### CMS 垃圾处理器： 追求最短停顿时间
    1.初始标记：为了收集应用程序的对象引用需要暂停应用程序线程，该阶段完成后，应用程序线程再次启动。
    2.并发标记：从第一阶段收集到的对象引用开始，遍历所有其他的对象引用。
    3.并发预清理：改变当运行第二阶段时，由应用程序线程产生的对象引用，以更新第二阶段的结果。
    4.重标记：由于第三阶段是并发的，对象引用可能会发生进一步改变。因此，应用程序线程会再一次被暂停以更新这些变化，并且在进行实际的清理之前确保一个正确的对象引用视图。这一阶段十分重要，因为必须避免收集到仍被引用的对象。
    5.并发清理：所有不再被应用的对象将从堆里清除掉。
    6.并发重置：收集器做一些收尾的工作，以便下一次 GC 周期能有一个干净的状态。
#### 6.G1   使用标记整理算法 能非常精确的控制停顿
    G1收集器是当今收集器技术发展最前沿的成果，它是一款面向服务端应用的收集器，它能充分利用多CPU、多核环境。因此它是一款并行与并发收集器，并且它能建立可预测的停顿时间模型。
    G1收集器 ：他将java堆分成多个大小固定的内存区域 后台维护一个优先级列表  采用标记整理算法  不会产生空间碎片  能够全区域的垃圾收集   能够非常精确的定位停顿既能M毫秒内垃圾收集使劲按不超过
    会在后台维护一个优先级列表  优先回收垃圾最多的区域  区域划分和有优先级的区域回收保证了G1收集器在有限时间内的效率
    
### Java 虚拟机退出
    Java 虚拟机的退出条件一般是：某些线程调用 Runtime 类或 System 类的 exit 方法，或是 Runtime 类的 halt 方法，并且 Java 安全管理器也允许这些 exit 或 halt 操作。
    
    
### Java  内存溢出问题：
    内存溢出是指创建了一个实例对象时，实例对象所占的内存空间大于栈的可用空间。
    如果出现了内存溢出问题，这往往是程序内存本身的内存大于我们给虚拟机配置的内存，这种情况我们可以采用-Xmx来解决问题
    Windows下1.5～2G
    Linux    2～3G
   