# java  jvm解析
## jvm的功能
 Java虚拟机的功能：
 运行时的垃圾回收，
 通过 ClassLoader 寻找和装载 class 文件，
 解释字节码成为指令并执行，提供 class 文件的运行环境
 提供与硬件交互的平台
## 类加载过程
JVM中类的装载是由ClassLoader和它的子类来实现的,Java ClassLoader 是一个重要的Java运行时系统组件
### 父类委派机制      
   先让父类做父类做不了再让子类做
   使用双亲为委派机制的原因:防止类的重复加载
Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、
转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的加载机制。
加载顺序：
一般顺序：静态块——>静态变量——>成员变量——>构造方法——>静态方法
1、静态代码块（只加载一次） 2、构造方法（创建一个实例就加载一次）
3、静态方法需要调用才会执行，所以最后结果没有


Java运行时的数据区：
PC 寄存器   线程私有  存放正在执行的字节码地址
程序计数器是一块较小的区域，它的作用可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的模型里，字节码指示器就是通过改变程序计数器的值来指定下一条需要执行的指令。分支，循环等基础功能就是依赖程序计数器来完成的。
每一条 Java虚拟机线程都有自己的 PC（ Program Counter）寄存器 
那 PC 寄存器就保存 Java 虚拟机正在执行的字节码指令的地址，如果该方法是 native 的，那 PC 寄存器的值是 undefined。 PC 寄存器的容量至少应当能保存一个 returnAddress 类型的数据或者一个与平台相关的本地指针的值 

Java虚拟机栈
存放基本类型的数据和对象的引用，但对象本身不存放在栈中，而是存放在堆中 
描述的是JAVA方法执行的内存模型：每个方法执行的时候都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法的被调用直至执行完成的过程，就对应着一个栈帧在虚拟机中从入栈到出栈的过程。所以也是线程私有的。
是一个线程的执行区域， 它保存着一个线程中的方法的调用状态， 也可以说， 一个Java线程的运行状态， 都由一个Java栈来保存。 在这个栈中， 每一方法对应一个栈帧， 请注意区分栈帧和栈这两个概念。栈指的是整个线程的执行栈， 栈帧是栈中的一个单位， 每个方法对应一个栈帧。JVM会对Java栈执行两种操作： 压栈和出栈。 这两种操作在执行时都是以帧（栈帧）为单位的。 当调用了一个新的方法， 就会压入一个栈帧， 当一个方法调用完成， 就会弹出这个方法的栈帧， 回到调用者的栈帧。
Java 堆
在 Java 虚拟机中，堆（ Heap）是可供各条线程共享的运行时内存区域，也是供所有类实例和数组对象分配内存的区域
垃圾回收器收集的区域
JAVA堆是被所有线程共享的区域
方法区  
主要存储被虚拟机加载的类信息，常量、静态变量
在 Java 虚拟机中，方法区（ Method Area） 是可供各条	线程共享的运行时内存区域它存储了每一个类的结构信息，例如运行时常量池（ Runtime Constant Pool）、字段和方法数据、构造函数和普通方法的字节码内容、还包括一些在类、实例、接口初始化时用到的特殊方法 
通常为了优化对象调用方法的速度，方法区的类型信息中增加一个指针，该指针指向一张记录该类方法入口的表（称为方法表），表中的每一项都是指向相应方法的指针
类信息：
类的全限定名
当前类的直接父类的全限定名
这个类是接口类型，类类型，还是枚举类型
类的访问修饰符信息
当前类型的超接口的全限定名
当前类型的常量池
字段信息
方法信息
运行时常量池 
运行时常量池（ Runtime Constant Pool）是每一个类或接口的常量池 
方法区的一部分，当然也是线程共享的咯。除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放各种字面量和符合引用。

字面量和符号引用，这部分 内容在类加载后存放到方法区
运行时的常量池相对于Class文件常量池的另外一个 重要的具备动态性，java语言并不要求常量一定只能在编译期产生，也就是并非预置入class文件中常量池的内容才能进入 方法区的常量池
运行时常量池 相对于class文件常量池的另外一个重要的特征是具备动态性，Java语言并不要求常量一定只能在编译期产生，也就是并非置入class文件中常量池的内容才能进入方法区运行时的常量池，在运行期间也会有新的常量放进池中。这种特性被开发人员利用的比较多的便是String类的intern（）方法。
既然运行时常量池是方法区的一部分，自然会受到方法区内存的限制，当常量无法再申请到内存的时候 会抛出outofMemoryError



