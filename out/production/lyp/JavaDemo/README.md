# jvm解析
## Java  的内存分配：
大对象直接进入老年代
java GC的范围是Java堆内存：

    Java堆内存分为三代：
    年轻代：新对象和没达到一定年龄的对象都在年轻代；
    老年代：被长时间使用的对象，老年代的内存空间应该要比年轻代更大；
    元空间(永久代)：像一些方法中的操作临时对象等，直接使用物理内存；
    Java  把内存分为两种   一种叫堆内存  一种叫栈内存 
    堆内存增长:  从低地址向高地址 
    栈内存地址 : 从高地址到第地址   
    堆大小 = 新生代 + 老年代。其中
    Edem : from : to = 8:1:1 
    对象在 Survivor 区每熬过一次 Minor GC，就将对象的年龄 + 1，当对象的年龄达到某个值时 ( 默认是 15 岁，可以通过参数 -XX:MaxTenuringThreshold 来设定 )，这些对象就会成为老年代。
    栈是通过esp指针，压参数esp指针地址变小，出栈，地址变大，而堆是通过brk或者mmap向系统要空间，然后堆增大   也就是说
## jvm的功能
    (1)运行时的垃圾回收，
    (2)通过 ClassLoader 寻找和装载 class 文件，解释字节码成为指令并执行，提供 class 文件的运行环境提供与硬件交互的平台
## 类加载过程
    JVM中类的装载是由ClassLoader和它的子类来实现的,Java ClassLoader 是一个重要的Java运行时系统组件
### 父类委派机制      
    先让父类做父类做不了再让子类做
    原因：使用双亲为委派机制的原因:防止类的重复加载
    Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、
    转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的加载机制。
### 加载顺序：
    一般顺序：静态块——>静态变量——>成员变量——>构造方法——>静态方法
    1、静态代码块（只加载一次） 
    2、构造方法（创建一个实例就加载一次）
    3、静态方法需要调用才会执行，所以最后结果没有
    
## Java运行时的数据区：
### PC 寄存器   
    线程私有  存放正在执行的字节码地址
       程序计数器是一块较小的区域，它的作用可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的模型里，字节码指示器就是通过改变程序计数器的值来指定下一条需要执行的指令。
       分支，循环等基础功能就是依赖程序计数器来完成的。每一条 Java虚拟机线程都有自己的 PC（ Program Counter）寄存器 
    那 PC 寄存器就保存 Java 虚拟机正在执行的字节码指令的地址，如果该方法是 native 的，那 PC 寄存器的值是 undefined。 
    PC 寄存器的容量至少应当能保存一个 returnAddress 类型的数据或者一个与平台相关的本地指针的值 
### Java虚拟机栈
    存放基本类型的数据和对象的引用，但对象本身不存放在栈中，而是存放在堆中 
        描述的是JAVA方法执行的内存模型：每个方法执行的时候都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法的被调用直至执行完成的过程，就对应着一个栈帧在虚拟机中从入栈到出栈的过程。所以也是线程私有的。
    是一个线程的执行区域， 它保存着一个线程中的方法的调用状态， 也可以说， 一个Java线程的运行状态， 都由一个Java栈来保存。 在这个栈中， 每一方法对应一个栈帧， 请注意区分栈帧和栈这两个概念。栈指的是整个线程的执行栈， 栈帧是栈中的一个单位， 每个方法对应一个栈帧。JVM会对Java栈执行两种操作： 压栈和出栈。 这两种操作在执行时都是以帧（栈帧）为单位的。 当调用了一个新的方法， 就会压入一个栈帧， 当一个方法调用完成， 就会弹出这个方法的栈帧， 回到调用者的栈帧。
### Java 堆
    在 Java 虚拟机中，堆（ Heap）是可供各条线程共享的运行时内存区域，也是供所有类实例和数组对象分配内存的区域
    垃圾回收器收集的区域  JAVA堆是被所有线程共享的区域
### 方法区  
    主要存储被虚拟机加载的类信息，常量、静态变量
    在 Java 虚拟机中，方法区（ Method Area） 是可供各条线程共享的运行时内存区域它存储了每一个类的结构信息，例如运行时常量池（ Runtime Constant Pool）、字段和方法数据、构造函数和普通方法的字节码内容、还包括一些在类、实例、接口初始化时用到的特殊方法 
    通常为了优化对象调用方法的速度，方法区的类型信息中增加一个指针，该指针指向一张记录该类方法入口的表（称为方法表），表中的每一项都是指向相应方法的指针
####  类信息：
#####（1）类的全限定名
#####（2）当前类的直接父类的全限定名
#####（3）这个类是接口类型，类类型，还是枚举类型
#####（4）类的访问修饰符信息
#####（5）当前类型的超接口的全限定名
#####（6）当前类型的常量池
#####（7）字段信息
#####（8）方法信息
    
### 运行时常量池 
    运行时常量池（ Runtime Constant Pool）是每一个类或接口的常量池 
    方法区的一部分，当然也是线程共享的咯。除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放各种字面量和符合引用。
    字面量和符号引用，这部分 内容在类加载后存放到方法区
    运行时的常量池相对于Class文件常量池的另外一个 重要的具备动态性，java语言并不要求常量一定只能在编译期产生，也就是并非预置入class文件中常量池的内容才能进入 方法区的常量池
    运行时常量池 相对于class文件常量池的另外一个重要的特征是具备动态性，Java语言并不要求常量一定只能在编译期产生，也就是并非置入class文件中常量池的内容才能进入方法区运行时的常量池，在运行期间也会有新的常量放进池中。这种特性被开发人员利用的比较多的便是String类的intern（）方法。
    既然运行时常量池是方法区的一部分，自然会受到方法区内存的限制，当常量无法再申请到内存的时候 会抛出outofMemoryError

## java 内存回收机制
### Java垃圾回收机制的原理：
        当创建一个对象时GC使用一系列软指针就会监控这个对象的地址和大小使用情况，并用一个对象表将这些软指针对应为对象的引用之所以称为软指针是因为他并不是直接指向对象的而是指向对象的引用。Java可以依次的检查每个对象通过更改对象表项垃圾收集器可以标记对象移除对象移动对象和检查对象
    垃圾收集器是自动运行的他会时不时的检查对象的各个引用分代。
### 垃圾收集方法：
    （1）引用计数法  
    （2）引用追踪器法（对象的引用遍历）沿着对象图上的每条链递归确定是否可达
### 常用算法：
    (1)采用的回收方法 ：分代回收
    (2)标记清除算法：容易造成内存碎片
    (3)Copying  将内存分成两块每次只是用一块    这样代价太高  算法代价太高  使用内存变为原来的一半
    (4)Mark-Compact 算法   存活对象向一端移动
### 具体过程：
    当GC线程启动时，会通过可达性分析法把Eden区和From Space区的存活对象复制到To Space区，然后把Eden Space和From Space区的对象释放掉。当GC轮训扫描To Space区一定次数后，
    把依然存活的对象复制到老年代，然后释放To Space区的对象。对象的内存分配，往大方向上讲就是在堆上分配，对象主要分配在新生代的Eden Space和From Space，少数情况下会直接分配在老年代。
    如果新生代的Eden Space和From Space的空间不足，则会发起一次GC，如果进行了GC之后，Eden Space和From Space能够容纳该对象就放在Eden Space和From Space。在GC的过程中，
    会将Eden Space和From  Space中的存活对象移动到To Space，然后将Eden Space和From Space进行清理。如果在清理的过程中，To Space无法足够来存储某个对象，就会将该对象移动到老年代中。
    在进行了GC之后，使用的便是Eden space和To Space了，下次GC时会将存活对象复制到From Space，如此反复循环。当对象在Survivor区躲过一次GC的话，其对象年龄便会加1，默认情况下，
    如果对象年龄达到15岁，就会移动到老年代中。（大于from或者to区的一半时就拷贝到内存区，还有就是new的对象太大时就直接放在老年代）生成新对象放在eden区，当Eden放满之后放
    生存年龄  复制一次熬过一次垃圾回收

#### 持久代:
    用于存放静态文件，如今Java类、方法等。
    类回收的前提这个类从来没有定义类的对象，不存在用反射的方式来释放class对象，类加载器被回收 
    垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收(Full GC)。如果你仔细查看垃圾收集器的输出信息，就会发现永久代也是被回收的。这就是为什么正确的永久代大小对避免Full GC是非常重要的原因。请参考下Java8：从永久代到元数据区
### 注：
    Java8中已经移除了永久代，新加了一个叫做元数据区的native内存区
    
### 垃圾收集器：
#### 1.Serial/Serial Old
    Serial/Serial Old收集器是最基本最古老的收集器，它是一个单线程收集器，并且在它进行垃圾收集时，必须暂停所有用户线程。Serial收集器是针对新生代的收集器，采用的是Copying算法，Serial Old收集器是针对老年代的收集器，采用的是Mark-Compact算法。它的优点是实现简单高效，但是缺点是会给用户带来停顿。
#### 2.ParNew
    ParNew收集器是Serial收集器的多线程版本，使用多个线程进行垃圾收集。
#### 3.Parallel Scavenge     目标：控制吞吐量
    Parallel Scavenge收集器是一个新生代的多线程收集器（并行收集器），它在回收期间不需要暂停其他用户线程，其采用的是Copying算法，该收集器与前两个收集器有所不同，它主要是为了达到一个可控的吞吐量。
#### 4.Parallel Old
    Parallel Old是Parallel Scavenge收集器的老年代版本（并行收集器），使用多线程和Mark-Compact算法。标记整理算法
#### 5.CMS   获取最短停顿时间   基于“标记清除算法”   并发收集  低停顿
    CMS（Current Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器，它是一种并发收集器，采用的是Mark-Sweep算法。
##### CMS缺点：
    1.对CPU资源敏感
    2.没有办法处理“浮动垃圾”肯能出出现Concurrent Mode Failure失败而导致一次Full Gc
    3.使用标记清除算法会产生大量的内存碎片
##### CMS 垃圾处理器： 追求最短停顿时间
    1.初始标记：为了收集应用程序的对象引用需要暂停应用程序线程，该阶段完成后，应用程序线程再次启动。
    2.并发标记：从第一阶段收集到的对象引用开始，遍历所有其他的对象引用。
    3.并发预清理：改变当运行第二阶段时，由应用程序线程产生的对象引用，以更新第二阶段的结果。
    4.重标记：由于第三阶段是并发的，对象引用可能会发生进一步改变。因此，应用程序线程会再一次被暂停以更新这些变化，并且在进行实际的清理之前确保一个正确的对象引用视图。这一阶段十分重要，因为必须避免收集到仍被引用的对象。
    5.并发清理：所有不再被应用的对象将从堆里清除掉。
    6.并发重置：收集器做一些收尾的工作，以便下一次 GC 周期能有一个干净的状态。
#### 6.G1   使用标记整理算法 能非常精确的控制停顿
    G1收集器是当今收集器技术发展最前沿的成果，它是一款面向服务端应用的收集器，它能充分利用多CPU、多核环境。因此它是一款并行与并发收集器，并且它能建立可预测的停顿时间模型。
    G1收集器 ：他将java堆分成多个大小固定的内存区域 后台维护一个优先级列表  采用标记整理算法  不会产生空间碎片  能够全区域的垃圾收集   能够非常精确的定位停顿既能M毫秒内垃圾收集使劲按不超过
    会在后台维护一个优先级列表  优先回收垃圾最多的区域  区域划分和有优先级的区域回收保证了G1收集器在有限时间内的效率
    
### Java 虚拟机退出
    Java 虚拟机的退出条件一般是：某些线程调用 Runtime 类或 System 类的 exit 方法，或是 Runtime 类的 halt 方法，并且 Java 安全管理器也允许这些 exit 或 halt 操作。
    
    
### Java  内存溢出问题：
    内存溢出是指创建了一个实例对象时，实例对象所占的内存空间大于栈的可用空间。
    如果出现了内存溢出问题，这往往是程序内存本身的内存大于我们给虚拟机配置的内存，这种情况我们可以采用-Xmx来解决问题
    Windows下1.5～2G
    Linux    2～3G
   
#### 标记清除算法：
    标记：标记的过程其实就是，遍历所有的GC Roots，然后将所有GC Roots可达的对象标记为存活的对象。
    清除：清除的过程将遍历堆中所有的对象，将没有标记的对象全部清除掉。
    也就是说，就是当程序运行期间，若可以使用的内存被耗尽的时候，GC线程就会被触发并将程序暂停，随后将依旧存活的对象标记一遍，最终再将堆中所有没被标记的对象全部清除掉，接下来便让程序恢复运行。
   
    疑问：为什么非要停止程序的运行呢？
    答：
    这个其实也不难理解，假设我们的程序与GC线程是一起运行的，各位试想这样一种场景。
    假设我们刚标记完图中最右边的那个对象，暂且记为A，结果此时在程序当中又new了一个新对象B，且A对象可以到达B对象。
    但是由于此时A对象已经标记结束，B对象此时的标记位依然是0，因为它错过了标记阶段。
    因此当接下来轮到清除阶段的时候，新对象B将会被苦逼的清除掉。如此一来，不难想象结果，GC线程将会导致程序无法正常工作。
    
##### 标记-清除算法的缺点：
    （1）首先，它的缺点就是效率比较低（递归与全堆对象遍历），导致stop the world的时间比较长，尤其对于交互式的应用程序来说简直是无法接受。
    试想一下，如果你玩一个网站，这个网站一个小时就挂五分钟，你还玩吗？
    （2）第二点主要的缺点，则是这种方式清理出来的空闲内存是不连续的，这点不难理解，我们的死亡对象都是随即的出现在内存的各个角落的，
    现在把它们清除之后，内存的布局自然会乱七八糟。而为了应付这一点，JVM就不得不维持一个内存的空闲列表，这又是一种开销。而且在分配数组对象的时候，寻找连续的内存空间会不太好找。
    
    
### 复制算法 （新生代的GC）
    
    复制算法的概念：
    将原有的内存空间分为两块，每次只使用其中一块，在垃圾回收时，将正在使用的内存中的存活对象复制到未使用的内存块中，
    之后，清除正在使用的内存块中的所有对象，交换两个内存的角色，完成垃圾回收。
    与标记-清除算法相比，复制算法是一种相对高效的回收方法
    不适用于存活对象较多的场合，如老年代（复制算法适合做新生代的GC）
    
### 标记-整理算法：（老年代的GC）
    引入：
        如果在对象存活率较高时就要进行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，
        以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选中这种算法。
    概念：
    标记-压缩算法适合用于存活对象较多的场合，如老年代。它在标记-清除算法的基础上做了一些优化。和标记-清除算法一样，标记-压缩算法也首先需要从根节点开始，
    对所有可达对象做一次标记；但之后，它并不简单的清理未标记的对象，而是将所有的存活对象压缩到内存的一端；之后，清理边界外所有的空间。
#### 标记：
   它的第一个阶段与标记/清除算法是一模一样的，均是遍历GC Roots，然后将存活的对象标记。
#### 整理：移动所有存活的对象，且按照内存地址次序依次排列，然后将末端内存地址以后的内存全部回收。因此，第二阶段才称为整理阶段。
   上图中可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。
   标记/整理算法不仅可以弥补标记/清除算法当中，内存区域分散的缺点，也消除了复制算法当中，内存减半的高额代价。
    
### 总结    
    但是，标记/整理算法唯一的缺点就是效率也不高。
    不仅要标记所有存活对象，还要整理所有存活对象的引用地址。从效率上来说，标记/整理算法要低于复制算法。    
    标记-清除算法、复制算法、标记整理算法的总结：    
    三个算法都基于根搜索算法去判断一个对象是否应该被回收，而支撑根搜索算法可以正常工作的理论依据，就是语法中变量作用域的相关内容。
    因此，要想防止内存泄露，最根本的办法就是掌握好变量作用域，而不应该使用C/C++式内存管理方式。    
    在GC线程开启时，或者说GC过程开始时，它们都要暂停应用程序（stop the world）。    
    它们的区别如下：（>表示前者要优于后者，=表示两者效果一样）
    
    （1）效率：复制算法>标记/整理算法>标记/清除算法（此处的效率只是简单的对比时间复杂度，实际情况不一定如此）。
    
    （2）内存整齐度：复制算法=标记/整理算法>标记/清除算法。
    
    （3）内存利用率：标记/整理算法=标记/清除算法>复制算法。
    
     注1：可以看到标记/清除算法是比较落后的算法了，但是后两种算法却是在此基础上建立的。
    
     注2：时间与空间不可兼得。
### 在JAVA语言中，可以当做GC roots的对象有以下几种：   
    1、虚拟机栈中的引用的对象。
    2、方法区中的类静态属性引用的对象。
    3、方法区中的常量引用的对象。   
    4、本地方法栈中JNI的引用的对象。
    
    Stop-The-World：
  
## 1、Stop-The-World概念：
    Java中一种全局暂停的现象。
    全局停顿，所有Java代码停止，native代码可以执行，但不能和JVM交互
    多半情况下是由于GC引起。
        少数情况下由其他情况下引起，如：Dump线程、死锁检查、堆Dump。
## 2、GC时为什么会有全局停顿？
        
            （1）避免无法彻底清理干净
        
        打个比方：类比在聚会，突然GC要过来打扫房间，聚会时很乱，又有新的垃圾产生，房间永远打扫不干净，只有让大家停止活动了，才能将房间打扫干净。
        
            况且，如果没有全局停顿，会给GC线程造成很大的负担，GC算法的难度也会增加，GC很难去判断哪些是垃圾。
        
        　 （2）GC的工作必须在一个能确保一致性的快照中进行。
        
        这里的一致性的意思是：在整个分析期间整个执行系统看起来就像被冻结在某个时间点上，不可以出现分析过程中对象引用关系还在不断变化的情况，该点不满足的话分析结果的准确性无法得到保证。
        
        这点是导致GC进行时必须停顿所有Java执行线程的其中一个重要原因。
        
        1）对新生代的对象的收集称为minor GC；
        
        （2）对旧生代的对象的收集称为Full GC；
        
        （3）程序中主动调用System.gc()强制执行的GC为Full GC。
        
        不同的对象引用类型， GC会采用不同的方法进行回收，JVM对象的引用分为了四种类型：
        
        （1）强引用：默认情况下，对象采用的均为强引用（这个对象的实例没有其他对象引用，GC时才会被回收）
        
        （2）软引用：软引用是Java中提供的一种比较适合于缓存场景的应用（只有在内存不够用的情况下才会被GC）
        
        （3）弱引用：在GC时一定会被GC回收
        
        （4）虚引用：由于虚引用只是用来得知对象是否被GC
